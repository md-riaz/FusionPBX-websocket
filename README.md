# FusionPBX WebSocket Library

This repository contains the PHP classes used by FusionPBX to implement a WebSocket
service.  The code can be used to build a scalable server that accepts multiple
clients and to create internal services which communicate over a WebSocket
connection.

## Running the WebSocket Service

The entry point for the WebSocket server is `resources/service/websockets.php`.
It loads the framework and creates a `websocket_service` instance:

```php
$ws_server = websocket_service::create();
exit($ws_server->run());
```

【F:resources/service/websockets.php†L40-L57】

When started, the service binds to the IP address and port configured in the
system settings.  The defaults are `127.0.0.1` and port `8080`:

```php
$ip = $settings->get('websocket_server', 'bind_ip_address', '127.0.0.1');
$port = intval($settings->get('websocket_server', 'bind_port', 8080));
```

【F:resources/classes/websocket_service.php†L116-L132】

## Building a Service

`base_websocket_system_service` is an abstract helper used for long running
services.  It reconnects to the WebSocket server when needed, registers topic
callbacks and processes incoming messages:

```php
$this->register_topics();
$this->on_topic('authenticate', [$this, 'on_authenticate']);
while ($this->running) {
    // reconnect, read events and fire timers
}
```

【F:resources/classes/base_websocket_system_service.php†L88-L115】

Child classes implement `register_topics()` to register callbacks for topics
and may override `on_timer()` for periodic work.  Responses are sent with
`respond()` which wraps a `websocket_message` and writes it on the client
socket.

## Clients and Subscribers

Every connection accepted by `websocket_service` becomes a `subscriber` object
which tracks the client, authentication token and subscribed services.  Messages
are delivered only to subscribers that are subscribed to a service:

```php
if (!$subscriber->has_subscribed_to($message->service_name())) {
    throw new subscriber_not_subscribed_exception($this->id);
}
$subscriber->send((string) $message);
```

【F:resources/classes/subscriber.php†L675-L707】

Permissions can be attached to messages using `permission_filter`.  The filter
compares message fields to required permissions and only forwards data when the
subscriber has that permission:

```php
public function __invoke(string $key, $value): ?bool {
    $permission = $this->field_map[$key] ?? null;
    if ($permission === null || $this->has_permission($permission)) {
        return true;
    }
    return false;
}
```

【F:resources/classes/permission_filter.php†L39-L49】

## Service Tokens

Services authenticate to the WebSocket server using tokens generated by
`websocket_client::create_service_token()`.  The method stores token data on the
filesystem so the server can later verify it:

```php
$token = (new token())->create($service_name);
$array['token']['name'] = $token['name'];
$array['token']['hash'] = $token['hash'];
file_put_contents($token_file, $file_contents);
```

【F:resources/classes/websocket_client.php†L382-L429】

The client then sends the token for authentication:

```php
$ws_client->authenticate($token_name, $token_hash);
```

【F:resources/classes/websocket_client.php†L370-L372】

## Example Client Usage

A basic PHP client can connect to the server and send messages using the
`websocket_client` class:

```php
$client = new websocket_client('ws://127.0.0.1:8080/');
$client->connect();
$client->send("Hello World!");
$client->disconnect();
```

【F:resources/classes/websocket_client.php†L441-L450】

## Summary

The classes in this repository provide the building blocks for a scalable
WebSocket service:

- `websocket_server` – low level server handling multiple clients.
- `websocket_service` – manages subscribers and message routing.
- `subscriber` – represents a connected client with permissions and token
  validation.
- `base_websocket_system_service` – helper for long running system services.
- `websocket_client` – simple PHP client for connecting and authenticating.

Together these functions allow services and web clients to communicate in real
time while enforcing permissions and handling many connections.
